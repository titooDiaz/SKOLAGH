{% extends 'base.html' %}
{% block content %}
{% load static %}
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #f8f9fa;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        #canvas {
            cursor: crosshair;
            display: block;
            background: white;
        }

        .toolbar {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 12px 20px;
            border-radius: 50px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            display: flex;
            gap: 8px;
            align-items: center;
            z-index: 1000;
        }

        .tool-btn {
            width: 44px;
            height: 44px;
            border: none;
            background: #f1f3f5;
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .tool-btn:hover {
            background: #e9ecef;
            transform: translateY(-2px);
        }

        .tool-btn.active {
            background: #228be6;
            color: white;
        }

        .divider {
            width: 1px;
            height: 30px;
            background: #e9ecef;
            margin: 0 4px;
        }

        .size-slider {
            width: 100px;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: #e9ecef;
            outline: none;
            border-radius: 3px;
            cursor: pointer;
        }

        .size-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #228be6;
            border-radius: 50%;
            cursor: pointer;
        }

        .size-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #228be6;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .color-picker {
            width: 44px;
            height: 44px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            padding: 0;
        }

        .hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            z-index: 1000;
        }

        svg {
            width: 24px;
            height: 24px;
        }

        .board-id {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 10px 20px;
            border-radius: 25px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            font-size: 14px;
            color: #495057;
            z-index: 1000;
        }

        .board-id strong {
            color: #228be6;
            font-weight: 600;
        }
    </style>
    
    <canvas id="canvas"></canvas>
    
    <div class="toolbar">
        <button class="tool-btn active" id="pencil" title="Lápiz">
            <svg fill="currentColor" viewBox="0 0 24 24">
                <path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/>
            </svg>
        </button>
        
        <button class="tool-btn" id="eraser" title="Borrador">
            <svg fill="currentColor" viewBox="0 0 24 24">
                <path d="M16.24 3.56l4.95 4.94c.78.79.78 2.05 0 2.84L12 20.53a4.008 4.008 0 0 1-5.66 0L2.81 17c-.78-.79-.78-2.05 0-2.84l10.6-10.6c.79-.78 2.05-.78 2.83 0M4.22 15.58l3.54 3.53c.78.79 2.04.79 2.83 0l3.53-3.53-6.36-6.36-3.54 3.54c-.78.78-.78 2.04 0 2.82z"/>
            </svg>
        </button>

        <div class="divider"></div>

        <input type="color" class="color-picker" id="colorPicker" value="#000000" title="Color">
        
        <div class="divider"></div>

        <input type="range" class="size-slider" id="sizeSlider" min="1" max="20" value="3" title="Grosor">
    </div>

    <div class="board-id">
        Tablero: <strong id="boardName">demo</strong>
    </div>

    <div class="hint">
        Arrastra para dibujar • Rueda del mouse para zoom • Clic derecho para mover
    </div>

    <script>
        // Configuración del tablero - FÁCIL DE CONECTAR A BACKEND
        const BOARD_ID = new URLSearchParams(window.location.search).get('board') || 'demo';
        const API_URL = '/api/boards'; // Endpoint para backend Python
        
        document.getElementById('boardName').textContent = BOARD_ID;

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const pencilBtn = document.getElementById('pencil');
        const eraserBtn = document.getElementById('eraser');
        const colorPicker = document.getElementById('colorPicker');
        const sizeSlider = document.getElementById('sizeSlider');

        // Estado del tablero
        let strokes = []; // Array de trazos - FÁCIL DE SERIALIZAR A JSON
        let currentStroke = null;
        let isDrawing = false;
        let currentTool = 'pencil';
        let currentColor = '#000000';
        let currentSize = 3;
        
        // Pan y Zoom
        let offsetX = 0;
        let offsetY = 0;
        let scale = 1;
        let isPanning = false;
        let lastPanX = 0;
        let lastPanY = 0;

        // Canvas setup
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            redraw();
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Herramientas
        pencilBtn.addEventListener('click', () => {
            currentTool = 'pencil';
            pencilBtn.classList.add('active');
            eraserBtn.classList.remove('active');
            canvas.style.cursor = 'crosshair';
        });

        eraserBtn.addEventListener('click', () => {
            currentTool = 'eraser';
            eraserBtn.classList.add('active');
            pencilBtn.classList.remove('active');
            canvas.style.cursor = 'cell';
        });

        colorPicker.addEventListener('input', (e) => {
            currentColor = e.target.value;
        });

        sizeSlider.addEventListener('input', (e) => {
            currentSize = parseInt(e.target.value);
        });

        // Convertir coordenadas de pantalla a mundo
        function screenToWorld(screenX, screenY) {
            return {
                x: (screenX - offsetX) / scale,
                y: (screenY - offsetY) / scale
            };
        }

        // Dibujar todos los trazos
        function redraw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);

            strokes.forEach(stroke => {
                if (stroke.points.length < 2) return;

                ctx.beginPath();
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                if (stroke.tool === 'eraser') {
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.lineWidth = stroke.size * 4;
                    ctx.strokeStyle = 'rgba(0,0,0,1)';
                } else {
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.strokeStyle = stroke.color;
                    ctx.lineWidth = stroke.size;
                }

                ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
                for (let i = 1; i < stroke.points.length; i++) {
                    ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
                }
                ctx.stroke();
            });

            ctx.restore();
        }

        // Mouse Events
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            
            if (e.button === 2 || e.button === 1) {
                e.preventDefault();
                isPanning = true;
                lastPanX = e.clientX;
                lastPanY = e.clientY;
                canvas.style.cursor = 'grabbing';
                return;
            }

            if (e.button === 0) {
                isDrawing = true;
                const pos = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);
                
                currentStroke = {
                    tool: currentTool,
                    color: currentColor,
                    size: currentSize,
                    points: [pos],
                    timestamp: Date.now() // Para sincronización
                };
                
                strokes.push(currentStroke);
                redraw();
                
                // AQUÍ SE ENVIARÁ AL BACKEND
                // sendStrokeStart(currentStroke);
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();

            if (isPanning) {
                const dx = e.clientX - lastPanX;
                const dy = e.clientY - lastPanY;
                offsetX += dx;
                offsetY += dy;
                lastPanX = e.clientX;
                lastPanY = e.clientY;
                redraw();
                return;
            }

            if (isDrawing && currentStroke) {
                const pos = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);
                currentStroke.points.push(pos);
                redraw();
                
                // AQUÍ SE ENVIARÁ AL BACKEND
                // sendStrokeUpdate(pos);
            }
        });

        canvas.addEventListener('mouseup', () => {
            if (isDrawing && currentStroke) {
                // AQUÍ SE FINALIZARÁ EL TRAZO EN EL BACKEND
                // sendStrokeEnd(currentStroke);
                currentStroke = null;
            }
            isDrawing = false;
            isPanning = false;
            canvas.style.cursor = currentTool === 'pencil' ? 'crosshair' : 'cell';
        });

        canvas.addEventListener('mouseout', () => {
            isDrawing = false;
            isPanning = false;
        });

        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // Zoom con rueda
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            const worldPos = screenToWorld(mouseX, mouseY);
            
            const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
            const newScale = Math.min(Math.max(scale * zoomFactor, 0.1), 5);
            
            scale = newScale;
            
            offsetX = mouseX - worldPos.x * scale;
            offsetY = mouseY - worldPos.y * scale;
            
            redraw();
        });

        // ============================================
        // FUNCIONES PARA BACKEND (Comentadas por ahora)
        // ============================================
        
        /*
        // Cargar tablero desde el servidor
        async function loadBoard() {
            try {
                const response = await fetch(`${API_URL}/${BOARD_ID}`);
                const data = await response.json();
                strokes = data.strokes || [];
                redraw();
            } catch (error) {
                console.error('Error cargando tablero:', error);
            }
        }

        // Enviar nuevo trazo al servidor
        async function sendStrokeStart(stroke) {
            try {
                await fetch(`${API_URL}/${BOARD_ID}/strokes`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        action: 'start',
                        stroke: stroke
                    })
                });
            } catch (error) {
                console.error('Error enviando trazo:', error);
            }
        }

        // Actualizar trazo en tiempo real
        async function sendStrokeUpdate(point) {
            try {
                await fetch(`${API_URL}/${BOARD_ID}/strokes/update`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        action: 'update',
                        point: point,
                        timestamp: Date.now()
                    })
                });
            } catch (error) {
                console.error('Error actualizando trazo:', error);
            }
        }

        // WebSocket para colaboración en tiempo real
        function setupWebSocket() {
            const ws = new WebSocket(`ws://localhost:8000/ws/${BOARD_ID}`);
            
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                
                if (data.action === 'new_stroke') {
                    strokes.push(data.stroke);
                    redraw();
                } else if (data.action === 'update_stroke') {
                    // Actualizar último trazo de otro usuario
                    const lastStroke = strokes[strokes.length - 1];
                    if (lastStroke) {
                        lastStroke.points.push(data.point);
                        redraw();
                    }
                }
            };
            
            return ws;
        }

        // Inicializar
        // loadBoard();
        // const ws = setupWebSocket();
        */

        // Hint
        setTimeout(() => {
            const hint = document.querySelector('.hint');
            hint.style.opacity = '0';
            hint.style.transition = 'opacity 0.5s';
        }, 3000);
    </script>
</body>
</html>
{% endblock content %}